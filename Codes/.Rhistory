data = data,
aes(x = data$runtime, y = data$revenue)) +
stat_density2d(aes(fill = ..level..), geom = "polygon") +
#geom_density2d() +
#stat_bin2d() +
#stat_binhex() +
ggtitle("Runtime vs. Revenue") +
xlab("Runtime (minutes)") +
ylab("Revenue")
ggplot(
data = data,
aes(x = data$runtime, y = data$revenue)) +
#stat_density2d(aes(fill = ..level..), geom = "polygon") +
#geom_density2d() +
#stat_bin2d() +
stat_binhex() +
ggtitle("Runtime vs. Revenue") +
xlab("Runtime (minutes)") +
ylab("Revenue")
ggplot(
data = data,
aes(x = data$runtime, y = data$revenue)) +
#stat_density2d(aes(fill = ..level..), geom = "polygon") +
#geom_density2d() +
stat_bin2d() +
#stat_binhex() +
ggtitle("Runtime vs. Revenue") +
xlab("Runtime (minutes)") +
ylab("Revenue")
hexbinplot(
x =  data$revenue ~ data$runtime,
data = data,
xbins = 30,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
hexbinplot(
x =  data$revenue ~ data$runtime,
data = data,
xbins = 10,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
hexbinplot(
x =  data$revenue ~ data$runtime,
data = data,
xbins = 50,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
hexbinplot(
x =  data$revenue ~ data$runtime,
data = data,
xbins = 25,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
hexbinplot(
x =  data$revenue ~ data$runtime,
data = data,
xbins = 30,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
contourplot(
x = data$revenue ~ data$runtime,
data = data,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
library(hexbin)
contourplot(
x = data$revenue ~ data$runtime,
data = data,
main = "Runtime vs. Box Office Revenue",
xlab = "Runtime (minutes)",
ylab = "Box Office ($M)")
hexbinplot(
x = data$revenue ~ data$runtime,
data = data,
xbins = 30,
main = "Runtime vs. Revenue",
xlab = "Runtime (minutes)",
ylab = "Revenue")
# Qualitative and Quantitative Bivariate Analysis
boxplot(data$runtime ~ data$budget,
xlab = "Class",
ylab = "Ticket Fare")
# Qualitative and Quantitative Bivariate Analysis
boxplot(data$budget ~ data$runtime,
xlab = "runtime",
ylab = "Budget")
ggplot(data, aes(x=data$runtime, y=data$budget)) +
geom_violin()
ggplot(data, aes(x=data$genre, y=data$budget)) +
geom_violin()
# 4.b ggplot
ggplot(
data = data,
aes(x = data$runtime, y = data$revenue)) +
#stat_density2d(aes(fill = ..level..), geom = "polygon") +
#geom_density2d() +
stat_bin2d() +
#stat_binhex() +
ggtitle("Runtime vs. Revenue") +
xlab("Runtime (minutes)") +
ylab("Revenue")
ggplot(data, aes(x=data$genre, y=data$budget)) +
geom_violin()
ggplot(data, aes(x=data$runtime, y=data$budget)) +
geom_violin()
ggplot(data, aes(x=data$genre, y=data$budget)) +
geom_violin()
ggplot(data, aes(x=data$budget, y=data$genre)) +
geom_violin()
ggplot(data, aes(x=data$genre, y=data$budget)) +
geom_violin()
# 5
plot(
x = data$genre,
y = data$budget
)
# 5
plot(
x = data$genre,
y = data$budget,
las = 2
)
ggplot(data, aes(x=data$genre, y=data$budget)) +
geom_violin()
# 5
plot(
x = data$genre,
y = data$budget,
las = 2
)
setX <- c(45, 80, 83, 78, 75, 77, 79, 83, 83, 100)
# Prob 1
#1.a
set.mean <- mean(setX)
#1.b
set.median <- median(setX)
#1.c
set.variance <- var(setX)
#1.d
set.std <- sd(setX)
#1.e
set.iqr <- IQR(setX)
# Prob 3
# 3.a
set.3a = setX < set.mean
# 3.b
setX[setX < set.mean]
# 3.c
setX[seq(1, length(setX), by = 2)]
# 3.d
scores.matrix <- matrix(setX, nrow=2, ncol=5, byrow = TRUE)
print(scores.matrix)
# 3.e
scores.matrix[,c(1,ncol(scores.matrix))]
# 3.f
dimnames(scores.matrix) <- list(
paste("Student_", seq(1:nrow(scores.matrix))),
paste("Quiz_", seq(1:ncol(scores.matrix)))
)
print(scores.matrix)
# 3.f
dimnames(scores.matrix) <- list(
paste("Student_", seq(1:nrow(scores.matrix)), sep=""),
paste("Quiz_", seq(1:ncol(scores.matrix)), sep="")
)
print(scores.matrix)
# Prob 4
Name = c("Pomana", "Williams","Stanford","Princeton", "Yale")
State = c("CA", "MA", "CA","NJ", "CT")
Cost = c(62632, 64020, 62801, 58965, 63970)
Population = c(1610, 2150, 18346, 8014, 12109)
colleges.info = data.frame(Name, State, Cost, Population)
# 4.a
summary(colleges.info$State)
summary(colleges.info$Cost)
#4.b
subset(colleges.info, Population > 5000)
#4.b
colleges.info.2016 <- colleges.info[,c(1:2,4)]
print(colleges.info.2016)
colleges.info.2016$Cost <- round(colleges.info$Cost * 1.05, 0)
print(colleges.info.2016)
#Read in data
selfesteem.data <- read.csv(".\\lab02.csv")
selfesteem.data
#Basic Scatterplot
?plot
plot(selfesteem.data$Height,selfesteem.data$Selfesteem)
#Scatterplot with labs, and controlling axes
plot(selfesteem.data$Height,selfesteem.data$Selfesteem,
main="Scatterplot of Person Height versus Self Esteem",
xlab = "Height", ylab="Self Esteem",
xlim=c(55, 75), ylim=c(2.5, 5.5), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
x.mean <- mean(selfesteem.data$Height)
x.mean
y.mean <- mean(selfesteem.data$Selfesteem)
y.mean
attach(selfesteem.data)
plot(Height,Selfesteem)
#Scatterplot with labs, and controlling axes
plot(Height,Selfesteem,
main="Scatterplot of Person Height versus Self Esteem",
xlab = "Height", ylab="Self Esteem",
xlim=c(55, 75), ylim=c(2.5, 5.5), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
#Scatterplot with labs, and controlling axes
plot(Height,Selfesteem,
main="Scatterplot of Person Height versus Self Esteem",
xlab = "Height", ylab="Self Esteem",
xlim=c(min(Height), 75), ylim=c(2.5, 5.5), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
#Scatterplot with labs, and controlling axes
plot(Height,Selfesteem,
main="Scatterplot of Person Height versus Self Esteem",
xlab = "Height", ylab="Self Esteem",
xlim=c(min(Height), max(Height)), ylim=c(2.5, 5.5), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
#Scatterplot with labs, and controlling axes
plot(Height,Selfesteem,
main="Scatterplot of Person Height versus Self Esteem",
xlab = "Height", ylab="Self Esteem",
xlim=c(min(Height), max(Height)), ylim=c(min(Selfesteem), 5.5), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
#Scatterplot with labs, and controlling axes
plot(Height,Selfesteem,
main="Scatterplot of Person Height versus Self Esteem",
xlab = "Height", ylab="Self Esteem",
xlim=c(min(Height), max(Height)), ylim=c(min(Selfesteem), max(Selfesteem)), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
points(65.28, 3.76, col="red", pch=19)
x.sd <- sd(selfesteem.data$Height)
x.sd
y.sd <- sd(selfesteem.data$Selfesteem)
y.sd
#Calculate Sample Correlation
cor(selfesteem.data$Height,selfesteem.data$Selfesteem, use="pairwise.complete.obs")
x.sd <- sd(Height)
x.sd
y.sd <- sd(Selfesteem)
y.sd
#Calculate Sample Correlation
cor(selfesteem.data$Height,selfesteem.data$Selfesteem, use="pairwise.complete.obs")
#Calculate Sample Correlation
cor(Height,Selfesteem, use="pairwise.complete.obs")
#Simple Linear Regression
m <- lm(Selfesteem~Height)
m
#Simple Linear Regression
m <- lm(Selfesteem~Height)
m
#Simple Linear Regression
m <- lm(Height)
m
#Simple Linear Regression
m <- lm(Selfesteem~Height)
m
#Adding regression line to the current plot
abline(m,col="red")
#Request important summary information from R about the model
summary(m)
#Request important summary information from R about the model
summary(m)
beta1 <- cor(selfesteem.data$Height,selfesteem.data$Selfesteem) * sd(selfesteem.data$Selfesteem)/sd(selfesteem.data$Height)
beta1
beta0 <- mean(selfesteem.data$Selfesteem)-beta1*mean(selfesteem.data$Height)
beta0
fitted(m)
#compute R square by hand
totalss <-sum((selfesteem.data$Selfesteem -mean(selfesteem.data$Selfesteem))^2)
regss <-sum((fitted(m) -mean(selfesteem.data$Selfesteem))^2)
residss <-sum((selfesteem.data$Selfesteem-fitted(m))^2)
rsquare <- regss/totalss
rsquare
#Read in data
prestige.data <- read.csv(".\\lab3-data.csv")
prestige.data
#Basic Scatterplot
?plot
plot(prestige.data$PrestigeScore,prestige.data$EducationLevel)
#Scatterplot with labs, and controlling axes
plot(prestige.data$PrestigeScore,prestige.data$EducationLevel,
main="Scatterplot of Person Prestige Score Based On Education Level",
xlab = "EducationLevel", ylab="Prestige Score",
xlim=c(10, 90), ylim=c(5, 20), pch = 8, col="seagreen3",
cex=1.5, cex.lab = 1.5, cex.main = 1.5)
#Calculate Sample Correlation
cor(prestige.data$EducationLevel,prestige.data$PrestigeScore, use="pairwise.complete.obs")
#Simple Linear Regression
m <- lm(prestige.data$PrestigeScore~prestige.data$EducationLevel+prestige.data$Income+prestige.data$PercentOfWomen)
m
#Request important summary information from R about the model
summary(m)
#compute R^2
totalss <-sum((prestige.data$PrestigeScore - mean(prestige.data$PrestigeScore))^2)
abline(m)
#Request important summary information from R about the model
summary(m)
#compute R^2
totalss <-sum((prestige.data$PrestigeScore - mean(prestige.data$PrestigeScore))^2)
regss <-sum((fitted(m) -mean(prestige.data$PrestigeScore))^2)
residss <-sum((prestige.data$PrestigeScore-fitted(m))^2)
rsquare <- regss/totalss
rsquare
#Simple Linear Regression
m <- lm(prestige.data$PrestigeScore~prestige.data$EducationLevel+prestige.data$Income+prestige.data$PercentOfWomen)
m
#compute R^2
totalss <-sum((prestige.data$PrestigeScore - mean(prestige.data$PrestigeScore))^2)
regss <-sum((fitted(m) -mean(prestige.data$PrestigeScore))^2)
residss <-sum((prestige.data$PrestigeScore-fitted(m))^2)
rsquare <- regss/totalss
rsquare
#read in data
data <- read.csv(".\\lab4-data.csv")
data
# summary for 2 columns (tratement, pain)
summary(data[,c(1,length(data))])
# summary for 2 columns (tratement, pain)
summary(data[,c(1,length(data))])
Ttable(data)
Table(data)
table(data)
table(data$Treatment, data$Pain)
attach(data)
table(Treatment, Pain)
addmargins(table)
addmargins(t)
t <- table(Treatment, Pain)
addmargins(t)
prop.table(t, 1)
# summary for 2 columns (tratement, pain)
summary(data[,c(1,length(data))])
#simple logistic regression model
m<-glm(data$Pain ~ data$Treatment, family = binomial)
summary(m)
#simple logistic regression model
m<-glm(Pain ~ Treatment, family = binomial)
summary(m)
t <- table(Treatment, Pain)
t
data$Treatment <- ifelse(data$Treatment == "New Treatment", 0, 1)
data$Treatment
#simple logistic regression model
m<-glm(Pain ~ Treatment, family = binomial)
summary(m)
# convert strings into numeric for GLM
Treatment <- ifelse(data$Treatment == "New Treatment", 0, 1)
# convert strings into numeric for GLM
Treatment <- ifelse(Treatment == "New Treatment", 0, 1)
data$Treatment
#simple logistic regression model
m<-glm(Pain ~ Treatment, family = binomial)
summary(m)
#simple logistic regression model
m<-glm(Pain ~ Treatment, family = binomial)
summary(m)
#compute McFadden's pseudo-R squared
#m<-glm(data$event ~ data$chol, family = binomial)
nullm <- glm(data$Pain ~ 1, family="binomial")
rsquare = 1-logLik(m)/logLik(nullm)
rsquare
#simple logistic regression model
m<-glm(data$Pain ~ data$Treatment, family = binomial)
summary(m)
# convert strings into numeric for GLM
data$Treatment <- ifelse(data$Treatment == "New Treatment", 1, 0)
#simple logistic regression model
m<-glm(data$Pain ~ data$Treatment, family = binomial)
summary(m)
# convert strings into numeric for GLM
data$Treatment <- ifelse(data$Treatment == "New Treatment", 0, 1)
#simple logistic regression model
m<-glm(data$Pain ~ data$Treatment, family = binomial)
summary(m)
#read in data
data <- read.csv(".\\lab4-data.csv")
data
attach(data)
# summary for 2 columns (tratement, pain)
summary(data[,c(1,length(data))])
t <- table(Treatment, Pain)
t
addmargins(t)
prop.table(t, 1) # 1 means summarize by column, 2 means summarize by row
# convert strings into numeric for GLM
data$Treatment <- ifelse(data$Treatment == "New Treatment", 0, 1)
#simple logistic regression model
m<-glm(data$Pain ~ data$Treatment, family = binomial)
summary(m)
#read in data
data <- read.csv(".\\lab4-data.csv")
data
attach(data)
# summary for 2 columns (tratement, pain)
summary(data[,c(1,length(data))])
t <- table(Treatment, Pain)
t
addmargins(t)
prop.table(t, 1) # 1 means summarize by column, 2 means summarize by row
# convert strings into numeric for GLM
data$Treatment <- ifelse(data$Treatment == "New Treatment", 1, 0)
#simple logistic regression model
m<-glm(data$Pain ~ data$Treatment, family = binomial)
summary(m)
rsquare = 1-logLik(m)/logLik(nullm)
rsquare
#multiple logistic regression model
multi.m<-glm(data$Pain ~ data$Treatment+data$Age+data$Severe, family = binomial)
summary(multi.m)
exp(0.02119)
# Odd per 1 unit increase in treatment
exp(multi.m$coefficients[2])
# Odd per 10 unit increase in age
exp(multi.m$coefficients[3]*10)
# Odd per 1 unit increase in severity
exp(multi.m$coefficients[4])
multi.rsquare = 1-logLik(multi.m)/logLik(nullm)
exp(0.02119)
multi.rsquare = 1-logLik(multi.m)/logLik(nullm)
rsquare
multi.rsquare
library(ROCR)
coronarydata <- read.csv(".\\lab08_data.csv")
install.packages(ROCR)
install.packages("ROCR")
# install.packages("ROCR")
library(ROCR)
coronarydata <- read.csv(".\\lab08_data.csv")
head(coronarydata)
library(rpart)
library(rpart)
tree.model <- rpart(coronarydata$ActualClass ~ coronarydata$Probability, data = coronarydata)
tree.prob <- predict(tree.model, coronarydata, type='prob')
tree.prob
# install.packages("ROCR")
library(ROCR)
data <- read.csv(".\\lab08_data.csv")
head(data)
library(rpart)
tree.model <- rpart(data$ActualClass ~ data$Probability, data = data)
tree.prob <- predict(tree.model, data, type='prob')
tree.prob
#create prediction object that can be examined with the plotting function of ROCR
#first argument is predicted probabilities for class Pain, second one is true class labels
pred <- prediction(predictions = tree.prob[,2], labels = data$event1)
#create prediction object that can be examined with the plotting function of ROCR
#first argument is predicted probabilities for class Pain, second one is true class labels
pred <- prediction(predictions = tree.prob[,2], labels = data$ActualClass)
#compute tpr and fpr from prediction object
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf, main="ROC curve", col = "blue")
#compute area under the curve from prediction object
#perf.auc is a performance object
perf.auc <- performance(pred, measure = "auc")
#the auc is stored as a list in the y.values slot
#unlist() simplifies lists to a vector of numeric values
unlist(perf.auc@y.values)
?performance
# install.packages("ROCR")
library(ROCR)
data <- read.csv(".\\lab08_data.csv")
head(data)
?performance
#compute tpr and fpr from prediction object
perf <- performance(, measure = "tpr", x.measure = "fpr")
library(rpart)
tree.model <- rpart(data$ActualClass ~ data$Probability, data = data)
tree.prob <- predict(tree.model, coronarydata, type='prob')
tree.prob
tree.prob[,2]
data[,1]
data[,1]
data[,2]
#create prediction object that can be examined with the plotting function of ROCR
#first argument is predicted probabilities for class ActualClass, second one is true class labels
pred <- prediction(predictions = data$Probability, labels = data$ActualClass)
#compute tpr and fpr from prediction object
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf, main="ROC curve", col = "blue")
#compute area under the curve from prediction object
#perf.auc is a performance object
perf.auc <- performance(pred, measure = "auc")
#the auc is stored as a list in the y.values slot
#unlist() simplifies lists to a vector of numeric values
unlist(perf.auc@y.values)
#the auc is stored as a list in the y.values slot
#unlist() simplifies lists to a vector of numeric values
unlist(perf.auc@y.values)
# install.packages("ROCR")
library(ROCR)
data <- read.csv(".\\lab08_data.csv")
head(data)
#create prediction object that can be examined with the plotting function of ROCR
#first argument is predicted probabilities for class ActualClass, second one is true class labels
pred <- prediction(predictions = data$Probability, labels = data$ActualClass)
?performance
#compute tpr and fpr from prediction object
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf, main="ROC curve", col = "blue")
#compute area under the curve from prediction object
#perf.auc is a performance object
perf.auc <- performance(pred, measure = "auc")
#the auc is stored as a list in the y.values slot
#unlist() simplifies lists to a vector of numeric values
unlist(perf.auc@y.values)
